<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Subscription Formatter</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/MotionPathPlugin.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Poppins:wght@300;400;600&display=swap');
        
        :root {
            --primary: #5a3a7e;
            --secondary: #9b6dff;
            --accent: #ff6b97;
            --dark: #1a1325;
            --light: #f0e6ff;
            --success: #64ecaa;
            --error: #ff5c7c;
            --text: #e0d3ff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 20% 35%, rgba(91, 58, 126, 0.2) 0%, transparent 30%),
                radial-gradient(circle at 80% 10%, rgba(155, 109, 255, 0.2) 0%, transparent 30%);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
        }
        
        header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
        }
        
        h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.8rem;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, var(--accent), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px rgba(155, 109, 255, 0.3);
            animation: titleGlow 3s infinite alternate;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            margin-top: 3rem;
        }
        
        .card {
            background: rgba(26, 19, 37, 0.8);
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(155, 109, 255, 0.2);
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            border-color: rgba(155, 109, 255, 0.4);
        }
        
        .card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(155, 109, 255, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
            z-index: 1;
        }
        
        .card:hover::before {
            transform: translateX(100%);
        }
        
        .card h2 {
            font-family: 'Cinzel', serif;
            margin-bottom: 1.5rem;
            color: var(--secondary);
            font-size: 1.5rem;
            border-bottom: 1px solid rgba(155, 109, 255, 0.3);
            padding-bottom: 0.5rem;
        }
        
        .glow-icon {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .glow-icon i {
            color: var(--accent);
            font-size: 1.2rem;
            animation: iconPulse 2s infinite;
        }
        
        .input-area, .output-area {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        textarea {
            background: rgba(26, 19, 37, 0.6);
            border: 1px solid rgba(155, 109, 255, 0.3);
            border-radius: 10px;
            padding: 1rem;
            color: var(--light);
            font-family: 'Poppins', sans-serif;
            resize: vertical;
            min-height: 150px;
            transition: all 0.3s ease;
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--secondary);
            box-shadow: 0 0 15px rgba(155, 109, 255, 0.4);
        }
        
        button {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(90, 58, 126, 0.5);
        }
        
        button i {
            font-size: 1.2rem;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(90, 58, 126, 0.7);
        }
        
        button::after {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: translateX(-100%);
        }
        
        button:hover::after {
            animation: buttonGlow 1s;
        }
        
        .button-container {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .copy-btn {
            background: transparent;
            border: 1px solid var(--secondary);
            color: var(--secondary);
        }
        
        .copy-btn:hover {
            background: rgba(155, 109, 255, 0.1);
        }
        
        pre {
            background: rgba(20, 15, 30, 0.8);
            padding: 1.5rem;
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid rgba(155, 109, 255, 0.2);
            position: relative;
            min-height: 100px;
            font-family: monospace;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            color: white;
            z-index: 100;
            transform: translateY(-100px);
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .success {
            background: var(--success);
            box-shadow: 0 5px 15px rgba(100, 236, 170, 0.3);
        }
        
        .error {
            background: var(--error);
            box-shadow: 0 5px 15px rgba(255, 92, 124, 0.3);
        }
        
        .floating-icons {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: -1;
        }
        
        .floating-icon {
            position: absolute;
            font-size: 1.5rem;
            color: rgba(155, 109, 255, 0.2);
            animation: floatAnimation 15s infinite linear;
        }
        
        footer {
            text-align: center;
            padding: 2rem 0;
            margin-top: 3rem;
            color: rgba(224, 211, 255, 0.6);
            font-size: 0.9rem;
        }
        
        /* Particles */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        
        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: var(--secondary);
            border-radius: 50%;
            opacity: 0.6;
            animation: particleAnimation 15s infinite linear;
        }
        
        /* Legend section */
        .legend {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(26, 19, 37, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(155, 109, 255, 0.2);
        }
        
        .legend h3 {
            font-family: 'Cinzel', serif;
            color: var(--secondary);
            margin-bottom: 1rem;
        }
        
        .legend-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-item i {
            color: var(--accent);
            font-size: 1.2rem;
        }

        .status-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(155, 109, 255, 0.2);
            padding: 0.3rem 0.8rem;
            border-radius: 50px;
            font-size: 0.8rem;
            color: var(--light);
        }
        
        .settings-panel {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(26, 19, 37, 0.4);
            border-radius: 10px;
            border: 1px dashed rgba(155, 109, 255, 0.2);
            display: none;
        }
        
        .settings-toggle {
            background: transparent;
            border: none;
            color: var(--secondary);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .settings-toggle:hover {
            text-decoration: underline;
        }
        
        .settings-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 0.8rem;
            margin-top: 1rem;
        }
        
        .setting-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .setting-item input {
            margin: 0;
            cursor: pointer;
        }
        
        .processing-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            color: var(--secondary);
            font-size: 0.9rem;
            margin-top: 0.5rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .processing-indicator.active {
            opacity: 1;
        }
        
        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(155, 109, 255, 0.3);
            border-top: 3px solid var(--secondary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        /* Pattern settings section */
        .pattern-settings {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px dashed rgba(155, 109, 255, 0.2);
        }
        
        .pattern-field {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .pattern-field input[type="text"] {
            flex: 1;
            background: rgba(26, 19, 37, 0.6);
            border: 1px solid rgba(155, 109, 255, 0.3);
            border-radius: 5px;
            padding: 0.5rem;
            color: var(--light);
            font-family: 'Poppins', sans-serif;
        }
        
        .pattern-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .pattern-button {
            padding: 0.5rem 1rem;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .legend-items {
                grid-template-columns: 1fr;
            }
            
            .button-container {
                flex-direction: column;
            }
        }
        
        /* Mystical Portal Styles */
        .mystical-portal-section {
            margin-top: 3rem;
            padding: 3rem 0;
            background: linear-gradient(rgba(26, 19, 37, 0.5), rgba(26, 19, 37, 0.8)),
                        url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDQwIDQwIj48ZyBmaWxsPSJyZ2JhKDEyNSwgOTUsIDE5MCwgMC4yKSI+PGNpcmNsZSBjeD0iNSIgY3k9IjUiIHI9IjEiLz48Y2lyY2xlIGN4PSIxNSIgY3k9IjUiIHI9IjEiLz48Y2lyY2xlIGN4PSIyNSIgY3k9IjUiIHI9IjEiLz48Y2lyY2xlIGN4PSIzNSIgY3k9IjUiIHI9IjEiLz48Y2lyY2xlIGN4PSI1IiBjeT0iMTUiIHI9IjEiLz48Y2lyY2xlIGN4PSIxNSIgY3k9IjE1IiByPSIxIi8+PGNpcmNsZSBjeD0iMjUiIGN5PSIxNSIgcj0iMSIvPjxjaXJjbGUgY3g9IjM1IiBjeT0iMTUiIHI9IjEiLz48Y2lyY2xlIGN4PSI1IiBjeT0iMjUiIHI9IjEiLz48Y2lyY2xlIGN4PSIxNSIgY3k9IjI1IiByPSIxIi8+PGNpcmNsZSBjeD0iMjUiIGN5PSIyNSIgcj0iMSIvPjxjaXJjbGUgY3g9IjM1IiBjeT0iMjUiIHI9IjEiLz48Y2lyY2xlIGN4PSI1IiBjeT0iMzUiIHI9IjEiLz48Y2lyY2xlIGN4PSIxNSIgY3k9IjM1IiByPSIxIi8+PGNpcmNsZSBjeD0iMjUiIGN5PSIzNSIgcj0iMSIvPjxjaXJjbGUgY3g9IjM1IiBjeT0iMzUiIHI9IjEiLz48L2c+PC9zdmc+');
            border-top: 1px solid rgba(155, 109, 255, 0.3);
            border-bottom: 1px solid rgba(155, 109, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .mystical-portal-section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(155, 109, 255, 0.15) 0%, transparent 70%);
            pointer-events: none;
        }

        .portal-container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
            position: relative;
            z-index: 2;
        }

        .portal-title {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(90deg, var(--accent), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px rgba(155, 109, 255, 0.3);
        }

        .portal-description {
            font-size: 1.1rem;
            max-width: 600px;
            margin: 0 auto 2.5rem;
            color: var(--text);
            opacity: 0.9;
            line-height: 1.6;
        }

        .portal-button {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            padding: 1.2rem 2.5rem;
            background: linear-gradient(135deg, rgba(90, 58, 126, 0.9), rgba(155, 109, 255, 0.9));
            color: white;
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 1.2rem;
            border-radius: 50px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            text-decoration: none;
            position: relative;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.21, 0.61, 0.35, 1);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3),
                        inset 0 0 20px rgba(255, 255, 255, 0.2);
            cursor: pointer;
        }

        .portal-button::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.8) 0%, transparent 10%);
            transform: scale(0);
            opacity: 0;
            transition: transform 0.7s ease-out, opacity 0.7s ease-out;
            z-index: 1;
            pointer-events: none;
        }

        .portal-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4),
                        inset 0 0 20px rgba(255, 255, 255, 0.3);
            letter-spacing: 1px;
        }

        .portal-button:hover::before {
            opacity: 0.3;
            transform: scale(1);
        }

        .portal-button:active {
            transform: translateY(0);
        }

        .portal-button-text {
            position: relative;
            z-index: 2;
        }

        .portal-runes {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            opacity: 0.7;
            transform: translateY(0);
            transition: all 0.3s ease;
        }

        .portal-button:hover .portal-runes {
            opacity: 1;
            transform: translateY(-3px);
        }

        .rune {
            font-size: 1rem;
            animation: runeGlow 3s infinite alternate;
        }

        .rune:nth-child(2) {
            animation-delay: 0.6s;
        }

        .rune:nth-child(3) {
            animation-delay: 1.2s;
        }

        .rune:nth-child(4) {
            animation-delay: 1.8s;
        }

        .rune:nth-child(5) {
            animation-delay: 2.4s;
        }
        
        /* Animations */
        @keyframes titleGlow {
            0% {
                text-shadow: 0 0 10px rgba(155, 109, 255, 0.3);
            }
            100% {
                text-shadow: 0 0 20px rgba(155, 109, 255, 0.6), 0 0 30px rgba(255, 107, 151, 0.4);
            }
        }
        
        @keyframes iconPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.9;
            }
            50% {
                transform: scale(1.1);
                opacity: 1;
            }
        }
        
        @keyframes buttonGlow {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }
        
        @keyframes floatAnimation {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.2;
            }
            90% {
                opacity: 0.2;
            }
            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        @keyframes particleAnimation {
            0% {
                transform: translateY(0);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateY(-100vh);
                opacity: 0;
            }
        }
        
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        @keyframes runeGlow {
            0% {
                opacity: 0.4;
                transform: scale(1);
                text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            }
            100% {
                opacity: 1;
                transform: scale(1.2);
                text-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
            }
        }

        /* Portal animation effects */
        .portal-active .particles::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(155, 109, 255, 0.2) 0%, transparent 70%);
            animation: pulseBackground 2s ease-out forwards;
            z-index: 10;
            pointer-events: none;
        }

        @keyframes pulseBackground {
            0% {
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        .magic-circle {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 300px;
            height: 300px;
            border-radius: 50%;
            border: 2px solid rgba(155, 109, 255, 0.7);
            box-shadow: 0 0 30px rgba(155, 109, 255, 0.5),
                        inset 0 0 30px rgba(155, 109, 255, 0.5);
            background: radial-gradient(circle at center, rgba(155, 109, 255, 0.2) 0%, transparent 70%);
            z-index: 20;
            opacity: 0;
            pointer-events: none;
        }

        .magic-circle::before {
            content: "";
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
            border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, 0.1);
            animation: rotate 8s linear infinite;
        }

        .magic-circle::after {
            content: "";
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border-radius: 50%;
            border: 2px solid rgba(255, 107, 151, 0.3);
            animation: rotate 5s linear infinite reverse;
        }

        @keyframes rotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .portal-active .magic-circle {
            animation: activatePortal 2s ease-out forwards;
        }

        @keyframes activatePortal {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0) rotate(0deg);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.5) rotate(360deg);
            }
        }

        .portal-active .floating-icon {
            animation: portalPull 1.5s ease-out forwards !important;
        }

        @keyframes portalPull {
            0% {
                transform: scale(1);
            }
            100% {
                transform: translateY(-50vh) translateX(calc(50vw - 100%)) scale(0);
            }
        }

        .portal-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 30;
            opacity: 0;
            pointer-events: none;
        }

        .portal-active .portal-flash {
            animation: portalFlash 0.5s ease-out 1.7s forwards;
        }

        @keyframes portalFlash {
            0% {
                opacity: 0;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                opacity: 0;
            }
        }

        /* Music player and visualization styles */
        .music-player {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(26, 19, 37, 0.7);
            backdrop-filter: blur(10px);
            padding: 0.7rem 1rem;
            border-radius: 50px;
            border: 1px solid rgba(155, 109, 255, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            transform: translateY(100px);
            opacity: 0;
        }
        
        .music-player.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .music-player:hover {
            border-color: rgba(155, 109, 255, 0.7);
            box-shadow: 0 5px 20px rgba(155, 109, 255, 0.5);
        }
        
        .music-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .music-toggle {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        
        .music-toggle:hover {
            transform: scale(1.1);
        }
        
        .music-toggle i {
            font-size: 1rem;
        }
        
        .prev-track, .next-track {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(155, 109, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--light);
            transition: all 0.3s ease;
        }
        
        .prev-track:hover, .next-track:hover {
            background: rgba(155, 109, 255, 0.3);
            transform: scale(1.1);
        }
        
        .shuffle-toggle {
            color: var(--light);
            font-size: 0.8rem;
            opacity: 0.7;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-left: 0.3rem;
        }
        
        .shuffle-toggle.active {
            color: var(--secondary);
            opacity: 1;
        }
        
        .shuffle-toggle:hover {
            opacity: 1;
        }
        
        .music-info {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }
        
        .music-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--light);
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .music-artist {
            font-size: 0.7rem;
            color: rgba(224, 211, 255, 0.7);
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .volume-icon {
            color: var(--light);
            font-size: 0.8rem;
            width: 12px;
        }
        
        .volume-slider {
            -webkit-appearance: none;
            width: 60px;
            height: 4px;
            background: rgba(155, 109, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--secondary);
            cursor: pointer;
            box-shadow: -80px 0 0 80px var(--secondary);
        }
        
        .volume-slider:focus {
            outline: none;
        }
        
        .visualizer-toggle {
            color: var(--light);
            font-size: 0.8rem;
            opacity: 0.7;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .visualizer-toggle:hover {
            opacity: 1;
        }
        
        .visualizer-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        .visualizer-container.active {
            opacity: 0.7;
        }
        
        .visualizer-container canvas {
            width: 100%;
            height: 100%;
        }
        
        .music-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(155, 109, 255, 0.2);
        }
        
        .music-progress-bar {
            height: 100%;
            background: var(--secondary);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .music-notification {
            position: fixed;
            bottom: 80px;
            right: 20px;
            padding: 0.7rem 1rem;
            background: rgba(26, 19, 37, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(155, 109, 255, 0.3);
            color: var(--light);
            transform: translateX(200px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        .music-notification.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .sound-orb {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(155, 109, 255, 0.8) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
            animation: orbFloat 5s infinite ease-in-out;
            opacity: 0;
        }
        
        @keyframes orbFloat {
            0%, 100% {
                transform: translateY(0) scale(1);
            }
            50% {
                transform: translateY(-20px) scale(1.1);
            }
        }
        
        /* Responsive adaptations for the music player */
        @media (max-width: 768px) {
            .music-player {
                bottom: 10px;
                right: 10px;
                padding: 0.5rem 0.7rem;
            }
            
            .music-title {
                max-width: 100px;
            }
            
            .volume-slider {
                width: 40px;
            }
        }
        
        .music-floater {
            position: fixed;
            top: -20px;
            left: -20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(155, 109, 255, 0.6) 0%, transparent 70%);
            pointer-events: none;
            z-index: 50;
            animation: musicFloat 3s infinite ease-in-out;
            opacity: 0;
        }
        
        @keyframes musicFloat {
            0% {
                transform: translateY(0) scale(1);
                opacity: 0;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                transform: translateY(-100px) scale(0);
                opacity: 0;
            }
        }

        /* Initial play overlay */
        .music-start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 19, 37, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }
        
        .music-start-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .music-start-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            box-shadow: 0 5px 30px rgba(155, 109, 255, 0.7);
            transition: all 0.3s ease;
            animation: pulse 2s infinite ease-in-out;
        }
        
        .music-start-button i {
            font-size: 2rem;
        }
        
        .music-start-text {
            margin-top: 1.5rem;
            color: var(--light);
            font-size: 1.2rem;
            text-align: center;
            max-width: 80%;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 5px 30px rgba(155, 109, 255, 0.7);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 5px 40px rgba(155, 109, 255, 0.9);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 5px 30px rgba(155, 109, 255, 0.7);
            }
        }
        
        /* Enhanced visualizations */
        .immersive-visualizer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0;
            transition: opacity 1s ease;
        }
        
        .immersive-visualizer.active {
            opacity: 1;
        }
        
        .frequency-circle {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle at center, rgba(155, 109, 255, 0.7) 0%, transparent 70%);
            opacity: 0;
            mix-blend-mode: screen;
        }
        
        .beat-ripple {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(1);
            background: transparent;
            border: 2px solid rgba(155, 109, 255, 0.5);
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }
        
        .beat-ripple.animate {
            animation: rippleEffect 2s ease-out forwards;
        }
        
        @keyframes rippleEffect {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.7;
                border-width: 2px;
            }
            100% {
                transform: translate(-50%, -50%) scale(20);
                opacity: 0;
                border-width: 1px;
            }
        }
        
        .music-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        /* Enhanced reactive elements */
        .container {
            transition: transform 0.2s ease-out;
        }
        
        .music-reactive {
            transition: all 0.2s ease;
        }
        
        /* Magic path for particles to follow */
        .magic-path {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: -1;
        }
        
        .frequency-particle {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at center, var(--primary) 0%, transparent 70%);
            mix-blend-mode: screen;
            filter: blur(2px);
            opacity: 0.7;
            z-index: -1;
        }
        
        /* Enhance existing elements with reactive classes */
        .header, .icon-wrapper, .settings-toggle, 
        .button, .settings-panel h3, .section-title {
            transition: all 0.3s ease;
        }
        
        .glow-effect {
            box-shadow: 0 0 10px rgba(155, 109, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .glow-text {
            text-shadow: 0 0 8px rgba(155, 109, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        /* Enhanced floating icons */
        .floating-icon {
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    
    <!-- Audio Element (Hidden) -->
    <audio id="background-music" preload="none">
        <source src="https://assets.mixkit.co/music/preview/mixkit-dreaming-big-31.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Simple Music Controls -->
    <div class="simple-player" style="position: fixed; bottom: 20px; right: 20px; z-index: 1000; background: rgba(26, 19, 37, 0.8); padding: 10px; border-radius: 10px; display: flex; align-items: center; gap: 10px;">
        <button id="simple-play-btn" style="background: var(--secondary); width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <i class="fas fa-play" id="simple-play-icon"></i>
        </button>
        <div style="color: white; font-size: 14px;">Play Music</div>
    </div>
    
    <!-- Music Start Overlay -->
    <div class="music-start-overlay" id="music-start-overlay">
        <div class="music-start-button">
            <i class="fas fa-play"></i>
        </div>
        <div class="music-start-text">
            Click to begin the magical audio experience
            <br><small>Headphones recommended for full immersion</small>
        </div>
    </div>
    
    <!-- Enhanced Music Visualization Container -->
    <div class="visualizer-container" id="visualizer-container">
        <canvas id="visualizer"></canvas>
    </div>
    
    <!-- Immersive Visualizer -->
    <div class="immersive-visualizer" id="immersive-visualizer"></div>
    <div class="magic-path" id="magic-path"></div>
    
    <!-- Music Player -->
    <div class="music-player" id="music-player">
        <div class="music-controls">
            <div class="prev-track" id="prev-track">
                <i class="fas fa-step-backward"></i>
            </div>
            <div class="music-toggle" id="music-toggle">
                <i class="fas fa-play" id="play-icon"></i>
            </div>
            <div class="next-track" id="next-track">
                <i class="fas fa-step-forward"></i>
            </div>
        </div>
        <div class="music-info">
            <div class="music-title" id="music-title">Magical Track</div>
            <div class="music-artist" id="music-artist">Enchanted Artist</div>
        </div>
        <div class="volume-control">
            <i class="fas fa-volume-up volume-icon"></i>
            <input type="range" min="0" max="100" value="70" class="volume-slider" id="volume-slider">
        </div>
        <div class="visualizer-toggle" id="visualizer-toggle">
            <i class="fas fa-wave-square"></i>
        </div>
        <div class="shuffle-toggle" id="shuffle-toggle">
            <i class="fas fa-random"></i>
        </div>
        <div class="music-progress">
            <div class="music-progress-bar" id="music-progress-bar"></div>
        </div>
    </div>
    
    <!-- Music Notification -->
    <div class="music-notification" id="music-notification">
        Music is now playing
    </div>
    
    <div class="container">
        <header>
            <h1>‚ú® Magical Subscription Formatter ‚ú®</h1>
            <p class="subtitle">Transform your plain subscription data into beautifully formatted content with magical emojis and enchanted styling</p>
        </header>
        
        <div class="app-container">
            <div class="card input-card">
                <h2 class="glow-icon"><i class="fas fa-magic"></i> Input Your Potion Ingredients</h2>
                <div class="input-area">
                    <textarea id="input-data" placeholder="Paste your subscription data here... (email:password | Plan = X Month | ExpireDate = YYYY-MM-DD | DaysLeft = X | AutoRenew = true/false | PaymentMethod = METHOD)"></textarea>
                    <button id="settings-toggle" class="settings-toggle">
                        <i class="fas fa-cog"></i> Advanced Settings
                    </button>
                    <div id="settings-panel" class="settings-panel">
                        <div class="settings-options">
                            <div class="setting-item">
                                <input type="checkbox" id="aggressive-parsing" checked>
                                <label for="aggressive-parsing">Aggressive Parsing</label>
                            </div>
                            <div class="setting-item">
                                <input type="checkbox" id="multi-strategy" checked>
                                <label for="multi-strategy">Multi-Strategy</label>
                            </div>
                            <div class="setting-item">
                                <input type="checkbox" id="deep-inspection" checked>
                                <label for="deep-inspection">Deep Inspection</label>
                            </div>
                            <div class="setting-item">
                                <input type="checkbox" id="error-recovery" checked>
                                <label for="error-recovery">Error Recovery</label>
                            </div>
                            <div class="setting-item">
                                <input type="checkbox" id="remove-tags" checked>
                                <label for="remove-tags">Remove Tag IDs</label>
                            </div>
                        </div>
                        
                        <div class="pattern-settings">
                            <h4>Tag Removal Patterns</h4>
                            <p>Add patterns to remove from passwords (e.g., TG tags)</p>
                            
                            <div id="pattern-container">
                                <div class="pattern-field">
                                    <input type="text" class="pattern-input" value="- by@\w+" placeholder="Regular expression pattern">
                                </div>
                            </div>
                            
                            <div class="pattern-actions">
                                <button class="pattern-button" id="add-pattern">
                                    <i class="fas fa-plus"></i> Add Pattern
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="button-container">
                        <button id="format-btn"><i class="fas fa-wand-magic-sparkles"></i> Cast Formatting Spell</button>
                        <button id="clear-btn" class="copy-btn"><i class="fas fa-broom"></i> Clear</button>
                    </div>
                    <div id="processing-indicator" class="processing-indicator">
                        <div class="spinner"></div>
                        <span>Casting powerful magic...</span>
                    </div>
                </div>
            </div>
            
            <div class="card output-card">
                <div class="status-badge" id="status-badge">Ready</div>
                <h2 class="glow-icon"><i class="fas fa-scroll"></i> Your Enchanted Output</h2>
                <div class="output-area">
                    <pre id="output-result">Your magical formatted output will appear here...</pre>
                    <div class="button-container">
                        <button id="copy-btn"><i class="fas fa-copy"></i> Copy to Spellbook</button>
                    </div>
                </div>
            </div>
            
            <div class="card legend">
                <h3 class="glow-icon"><i class="fas fa-book-open"></i> Legend of Magical Symbols</h3>
                <div class="legend-items">
                    <div class="legend-item">
                        <i class="fas fa-envelope"></i>
                        <span>üìß Email</span>
                    </div>
                    <div class="legend-item">
                        <i class="fas fa-key"></i>
                        <span>Password in `monospace`</span>
                    </div>
                    <div class="legend-item">
                        <i class="fas fa-calendar"></i>
                        <span>üóì Plan Duration</span>
                    </div>
                    <div class="legend-item">
                        <i class="fas fa-hourglass-end"></i>
                        <span>‚è≥ Expiration Date</span>
                    </div>
                    <div class="legend-item">
                        <i class="fas fa-clock"></i>
                        <span>‚è≥ Days Left</span>
                    </div>
                    <div class="legend-item">
                        <i class="fas fa-sync-alt"></i>
                        <span>‚úÖ/‚ùå Auto Renew</span>
                    </div>
                    <div class="legend-item">
                        <i class="fas fa-credit-card"></i>
                        <span>üí≥ Payment Method</span>
                    </div>
                </div>
            </div>
            
            <!-- Mystical Portal Section -->
            <div class="mystical-portal-section">
                <div class="portal-container">
                    <h3 class="portal-title">‚úß Discover the Arcane Codex ‚úß</h3>
                    <p class="portal-description">Venture deeper into the magical realm where more enchanted creations await. The Fallen Angel's repository holds mysteries beyond imagination...</p>
                    
                    <a href="https://github.com/Darkphoenixir" target="_blank" class="portal-button" id="portal-button">
                        <span class="portal-button-text">Open the Mystical Gateway</span>
                        <div class="portal-runes">
                            <span class="rune">‚ö°</span>
                            <span class="rune">‚ú¶</span>
                            <span class="rune">‚úß</span>
                            <span class="rune">‚öù</span>
                            <span class="rune">‚öú</span>
                        </div>
                    </a>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Created with ‚ú® magical code ‚ú® | Fantasy Subscription Formatter</p>
        </footer>
    </div>
    
    <div class="notification" id="notification"></div>
    
    <!-- Add Magic Circle for Portal Effect -->
    <div class="magic-circle"></div>
    <div class="portal-flash"></div>
    
    <script>
        // Create floating icons and particles
        document.addEventListener('DOMContentLoaded', function() {
            // Simple music player
            const music = document.getElementById('background-music');
            const playBtn = document.getElementById('simple-play-btn');
            const playIcon = document.getElementById('simple-play-icon');
            
            // Set initial volume
            music.volume = 0.7;
            
            // Simple play/pause functionality
            playBtn.addEventListener('click', function() {
                console.log("Play button clicked");
                if (music.paused) {
                    let playPromise = music.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(_ => {
                            // Playback started
                            playIcon.className = 'fas fa-pause';
                            console.log("Music started playing");
                        })
                        .catch(error => {
                            // Auto-play was prevented
                            console.log("Playback prevented:", error);
                            // Try again with user interaction
                            playIcon.className = 'fas fa-play';
                        });
                    }
                } else {
                    music.pause();
                    playIcon.className = 'fas fa-play';
                    console.log("Music paused");
                }
            });
            
            // Create floating icons
            const container = document.querySelector('.container');
            const numberOfIcons = 15;
            
            // Magic icons to use
            const icons = [
                'fa-magic',
                'fa-moon',
                'fa-star',
                'fa-gem',
                'fa-hat-wizard',
                'fa-scroll',
                'fa-wand-sparkles'
            ];
            
            for (let i = 0; i < numberOfIcons; i++) {
                const icon = document.createElement('div');
                icon.className = 'floating-icon';
                
                const randomIcon = icons[Math.floor(Math.random() * icons.length)];
                icon.innerHTML = `<i class="fas ${randomIcon}"></i>`;
                
                // Random position, size, and animation
                icon.style.left = `${Math.random() * 100}%`;
                icon.style.top = `${Math.random() * 100}%`;
                icon.style.animationDuration = `${15 + Math.random() * 30}s`;
                icon.style.animationDelay = `${Math.random() * 5}s`;
                
                container.appendChild(icon);
            }
            
            // Create particles
            const particles = document.getElementById('particles');
            const numberOfParticles = 30;
            
            for (let i = 0; i < numberOfParticles; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle portal-particle';
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                particle.style.opacity = `${Math.random() * 0.5 + 0.1}`;
                particle.style.width = `${Math.random() * 10 + 5}px`;
                particle.style.height = particle.style.width;
                particle.style.animationDuration = `${15 + Math.random() * 30}s`;
                
                particles.appendChild(particle);
            }
            
            // Add click to Settings toggle
            const settingsToggle = document.getElementById('settings-toggle');
            const settingsPanel = document.getElementById('settings-panel');
            
            if (settingsToggle && settingsPanel) {
                settingsToggle.addEventListener('click', function() {
                    settingsPanel.classList.toggle('show');
                });
            }
            
            // Add pattern button
            const addPatternBtn = document.getElementById('add-pattern-btn');
            if (addPatternBtn) {
                addPatternBtn.addEventListener('click', function() {
                    const patternsList = document.getElementById('patterns-list');
                    const index = patternsList.children.length + 1;
                    
                    const patternItem = document.createElement('div');
                    patternItem.className = 'pattern-item';
                    patternItem.innerHTML = `
                        <input type="text" placeholder="Enter regex pattern" class="pattern-input">
                        <button class="remove-pattern"><i class="fas fa-times"></i></button>
                    `;
                    
                    patternsList.appendChild(patternItem);
                    
                    // Add remove pattern functionality
                    const removeBtn = patternItem.querySelector('.remove-pattern');
                    removeBtn.addEventListener('click', function() {
                        patternsList.removeChild(patternItem);
                    });
                });
            }

            // Initialize formatter
            const formatter = new UltraFormatter();
            window.formatter = formatter;
        });
        
        // UltraFormatter - Advanced version with TG ID pattern removal and more robust parsing
        class UltraFormatter {
            constructor() {
                this.options = {
                    aggressiveParsing: true,
                    multiStrategy: true,
                    deepInspection: true,
                    errorRecovery: true,
                    removeTags: true
                };
                
                // Default patterns to remove from passwords (like TG IDs)
                this.removalPatterns = [
                    /\s*-\s*by@[A-Za-z0-9_]+/g,  // - by@USERNAME pattern
                    /\s*-\s*BY@[A-Za-z0-9_]+/g,   // - BY@USERNAME pattern (uppercase)
                    /\s*-\s*By@[A-Za-z0-9_]+/g,   // - By@USERNAME pattern (mixed case) 
                    /\s*-\s*by@L_E_O_U_S_E_S/g,   // Specific pattern from example
                    /\s*-\s*by[A-Za-z0-9@_]+/g    // More general pattern for by tags
                ];
                
                // Known email and domain patterns for better detection
                this.emailDomains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'icloud.com', 'aol.com', 'protonmail.com', 'lynsoluciones.es'];
                
                // Known payment methods
                this.paymentMethods = {
                    'CREDIT_CARD': 'üí≥',
                    'PAYPAL': 'üíµ',
                    'APP_STORE_AUTO_RENEWABLE': 'üçé',
                    'APP_STORE': 'üçé',
                    'GOOGLE_PLAY': 'ü§ñ',
                    'PLAY_STORE': 'ü§ñ',
                    'BITCOIN': '‚Çø',
                    'CRYPTO': '‚Çø',
                    'CB_CREDITCARD': 'üí≥',
                    'CB_PAYPAL': 'üíµ'
                };
                
                // Common field name variations for normalization
                this.fieldVariations = {
                    'plan': ['plan', 'subscription', 'sub', 'package'],
                    'expiredate': ['expiredate', 'expire date', 'expiration date', 'expiry', 'expires', 'exp date'],
                    'daysleft': ['daysleft', 'days left', 'remaining days', 'days remaining'],
                    'autorenew': ['autorenew', 'auto renew', 'auto renewal', 'renewal'],
                    'paymentmethod': ['paymentmethod', 'payment method', 'payment', 'method', 'paid with']
                };
            }
            
            // Update formatting options
            setOptions(options) {
                this.options = { ...this.options, ...options };
            }
            
            // Set removal patterns
            setRemovalPatterns(patterns) {
                if (patterns && patterns.length > 0) {
                    // Convert string patterns to RegExp objects
                    this.removalPatterns = patterns.map(pattern => {
                        if (typeof pattern === 'string' && pattern.trim()) {
                            try {
                                return new RegExp(pattern, 'g');
                            } catch (error) {
                                console.error('Invalid regex pattern:', pattern, error);
                                // Add a notification for invalid patterns
                                if (typeof showNotification === 'function') {
                                    showNotification(`Invalid pattern: ${pattern}`, 'error');
                                }
                                return null;
                            }
                        }
                        return pattern;
                    }).filter(pattern => pattern !== null);
                }
            }
            
            // Main formatting function
            async format(inputText) {
                if (!inputText || !inputText.trim()) {
                    return { success: false, message: 'No input provided', result: null };
                }
                
                try {
                    // Apply corrections to fix known issues in the input
                    let processedInput = this.preProcessInput(inputText);
                    
                    // Try multiple strategies to parse accounts
                    const strategies = [
                        this.extractAccountsByPattern.bind(this),
                        this.extractAccountsByLines.bind(this),
                        this.extractAccountsByDelimiters.bind(this),
                        this.extractAccountsByEmailPasswordPattern.bind(this)
                    ];
                    
                    // Use all strategies and pick the best result
                    let bestResult = { accounts: [], quality: 0 };
                    
                    // If multi-strategy is enabled, try all strategies
                    if (this.options.multiStrategy) {
                        for (const strategy of strategies) {
                            const result = await strategy(processedInput);
                            
                            // Evaluate the quality of the result
                            const quality = this.evaluateResultQuality(result, processedInput);
                            
                            // Keep the best result
                            if (quality > bestResult.quality) {
                                bestResult = { accounts: result, quality };
                            }
                        }
                    } else {
                        // Just use the first strategy if multi-strategy is disabled
                        bestResult.accounts = await strategies[0](processedInput);
                    }
                    
                    // If we have no accounts after trying all strategies
                    if (bestResult.accounts.length === 0) {
                        // Try one more time with a more aggressive approach
                        if (this.options.aggressiveParsing) {
                            bestResult.accounts = await this.aggressiveExtraction(processedInput);
                        }
                    }
                    
                    // Post-process accounts to ensure consistency and fix any issues
                    const processedAccounts = this.postProcessAccounts(bestResult.accounts);
                    
                    // Format the output
                    const formattedOutput = this.formatOutput(processedAccounts);
                    
                    return {
                        success: true,
                        result: formattedOutput,
                        accounts: processedAccounts,
                        message: `Successfully formatted ${processedAccounts.length} account(s)`
                    };
                } catch (error) {
                    console.error('Error in formatter:', error);
                    
                    // Try error recovery if enabled
                    if (this.options.errorRecovery) {
                        try {
                            const recoveredAccounts = this.emergencyRecovery(inputText);
                            if (recoveredAccounts.length > 0) {
                                const formattedOutput = this.formatOutput(recoveredAccounts);
                                return {
                                    success: true,
                                    result: formattedOutput,
                                    accounts: recoveredAccounts,
                                    message: `Recovered ${recoveredAccounts.length} account(s) after error`
                                };
                            }
                        } catch (recoveryError) {
                            console.error('Recovery failed:', recoveryError);
                        }
                    }
                    
                    return {
                        success: false,
                        message: `Error: ${error.message}`,
                        result: null
                    };
                }
            }
            
            // Pre-process the input to fix known issues
            preProcessInput(input) {
                let processed = input;
                
                // Fix known issues with specific patterns
                processed = processed.replace(/\s*\|\s*/g, ' | '); // Normalize separators
                
                // Ensure payment methods are properly separated
                const paymentMethodsKeys = Object.keys(this.paymentMethods).join('|');
                const paymentMethodRegex = new RegExp(`(PaymentMethod\\s*=\\s*(${paymentMethodsKeys}))([a-zA-Z0-9._-]+@)`, 'g');
                processed = processed.replace(paymentMethodRegex, '$1 | $3');
                
                return processed;
            }
            
            // Clean up passwords by removing TG IDs and other unwanted patterns
            cleanPassword(password) {
                if (!password) return password;
                let cleaned = password.trim();
                
                // Apply removal patterns if enabled
                if (this.options.removeTags && this.removalPatterns.length > 0) {
                    // First, check for and handle the specific "by@L_E_O_U_S_E_S" pattern
                    if (cleaned.includes("by@L_E_O_U_S_E_S") || 
                        cleaned.includes("by@l_e_o_u_s_e_s") ||
                        cleaned.includes("BY@L_E_O_U_S_E_S")) {
                        
                        // Find the position of the tag
                        const tagPos = Math.max(
                            cleaned.indexOf("by@L_E_O_U_S_E_S"),
                            cleaned.indexOf("by@l_e_o_u_s_e_s"),
                            cleaned.indexOf("BY@L_E_O_U_S_E_S")
                        );
                        
                        if (tagPos > 0) {
                            // Truncate at the position of the tag
                            cleaned = cleaned.substring(0, tagPos).trim();
                        }
                    }
                    
                    // Then apply all other regex patterns
                    for (const pattern of this.removalPatterns) {
                        try {
                            cleaned = cleaned.replace(pattern, '');
                        } catch (error) {
                            console.warn('Error applying pattern:', pattern, error);
                            // Continue with other patterns
                        }
                    }
                }
                
                // Trim any remaining whitespace
                cleaned = cleaned.trim();
                
                return cleaned;
            }
            
            // Strategy 1: Extract accounts by email:password pattern
            async extractAccountsByPattern(input) {
                const accounts = [];
                
                // Match all email:password patterns
                const emailPasswordRegex = /([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)\s*:\s*([^|\n]+)/g;
                const matches = [...input.matchAll(emailPasswordRegex)];
                
                if (matches.length === 0) return accounts;
                
                for (let i = 0; i < matches.length; i++) {
                    const match = matches[i];
                    const email = match[1].trim();
                    let password = match[2].trim();
                    
                    // Clean the password by removing TG IDs, etc.
                    password = this.cleanPassword(password);
                    
                    // Find the start and end of this account's data
                    const startPos = match.index;
                    let endPos;
                    
                    if (i < matches.length - 1) {
                        // Find the next email pattern
                        endPos = matches[i + 1].index;
                    } else {
                        // This is the last account
                        endPos = input.length;
                    }
                    
                    // Extract the full account data
                    const accountData = input.substring(startPos, endPos);
                    
                    // Create an account object with the email and password
                    const account = { email, password };
                    
                    // Extract other fields from the account data
                    this.extractFields(account, accountData);
                    
                    accounts.push(account);
                }
                
                return accounts;
            }
            
            // Strategy 2: Extract accounts by lines
            async extractAccountsByLines(input) {
                const accounts = [];
                
                // Split the input by newlines and process each line
                const lines = input.split('\n').filter(line => line.trim());
                
                for (const line of lines) {
                    // Check if the line contains an email:password pattern
                    const emailPasswordMatch = line.match(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)\s*:\s*([^|\n]+)/);
                    if (!emailPasswordMatch) continue;
                    
                    const email = emailPasswordMatch[1].trim();
                    let password = emailPasswordMatch[2].trim();
                    
                    // Clean the password by removing TG IDs, etc.
                    password = this.cleanPassword(password);
                    
                    // Create an account object with the email and password
                    const account = { email, password };
                    
                    // Extract other fields from the line
                    this.extractFields(account, line);
                    
                    accounts.push(account);
                }
                
                return accounts;
            }
            
            // Strategy 3: Extract accounts by delimiters (special separators)
            async extractAccountsByDelimiters(input) {
                const accounts = [];
                
                // Try to find logical separators between accounts
                let sections = [input];
                
                // Look for common account separators
                const separators = [
                    /(?:\r?\n){2,}/,  // Multiple newlines
                    /---+/,           // Dashes
                    /===+/,           // Equal signs
                    /\*\*\*+/,        // Asterisks
                    /_{3,}/           // Underscores
                ];
                
                for (const separator of separators) {
                    // If we already found good sections, stop
                    if (sections.length > 1) break;
                    
                    // Try this separator
                    const split = input.split(separator).filter(s => s.trim());
                    
                    // Check if this separator gives us multiple sections with email:password patterns
                    let validSections = 0;
                    for (const section of split) {
                        if (section.match(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)\s*:\s*([^|\n]+)/)) {
                            validSections++;
                        }
                    }
                    
                    // If most sections contain email:password, this is likely a good separator
                    if (validSections > 0 && validSections / split.length > 0.5) {
                        sections = split;
                    }
                }
                
                // Process each section as a potential account
                for (const section of sections) {
                    // Check if the section contains an email:password pattern
                    const emailPasswordMatch = section.match(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)\s*:\s*([^|\n]+)/);
                    if (!emailPasswordMatch) continue;
                    
                    const email = emailPasswordMatch[1].trim();
                    let password = emailPasswordMatch[2].trim();
                    
                    // Clean the password by removing TG IDs, etc.
                    password = this.cleanPassword(password);
                    
                    // Create an account object with the email and password
                    const account = { email, password };
                    
                    // Extract other fields from the section
                    this.extractFields(account, section);
                    
                    accounts.push(account);
                }
                
                return accounts;
            }
            
            // Strategy 4: Extract accounts by email-password without colon
            async extractAccountsByEmailPasswordPattern(input) {
                const accounts = [];
                
                // More flexible pattern to find email and password combinations
                const emailRegex = /([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/g;
                const matches = [...input.matchAll(emailRegex)];
                
                if (matches.length === 0) return accounts;
                
                for (let i = 0; i < matches.length; i++) {
                    const match = matches[i];
                    const email = match[1].trim();
                    
                    // Find the start and end of this account's data
                    const startPos = match.index;
                    let endPos;
                    
                    if (i < matches.length - 1) {
                        // Find the next email pattern
                        endPos = matches[i + 1].index;
                    } else {
                        // This is the last account
                        endPos = input.length;
                    }
                    
                    // Extract the account data
                    let accountData = input.substring(startPos, endPos);
                    
                    // Try to find the password
                    // First, look for a colon pattern
                    let passwordMatch = accountData.match(/:\s*([^|\n]+)/);
                    
                    // If no colon, look for common separators
                    if (!passwordMatch) {
                        passwordMatch = accountData.match(/[|,;\s]\s*([a-zA-Z0-9._!@#$%^&*()-+=]{6,})/);
                    }
                    
                    // Skip if we can't find a password
                    if (!passwordMatch) continue;
                    
                    let password = passwordMatch[1].trim();
                    
                    // Clean the password by removing TG IDs, etc.
                    password = this.cleanPassword(password);
                    
                    // Create an account object with the email and password
                    const account = { email, password };
                    
                    // Extract other fields from the account data
                    this.extractFields(account, accountData);
                    
                    accounts.push(account);
                }
                
                return accounts;
            }
            
            // Aggressive extraction when other methods fail
            async aggressiveExtraction(input) {
                const accounts = [];
                
                // Define a pattern that's very flexible but might have false positives
                const bareEmailRegex = /([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/g;
                const emails = [...input.matchAll(bareEmailRegex)].map(m => m[1]);
                
                // If no emails found, give up
                if (emails.length === 0) return accounts;
                
                // For each email, try to find a nearby password
                for (const email of emails) {
                    // Find the position of this email in the input
                    const emailPos = input.indexOf(email);
                    
                    // Look for a password pattern in the next 200 characters
                    const context = input.substring(emailPos, emailPos + 200);
                    
                    // Various password patterns to try
                    const passwordPatterns = [
                        /:\s*([^|\n]{4,30})/,                      // Colon followed by non-separator chars
                        /[|,;\s]\s*([A-Za-z0-9._!@#$%^&*()-+=]{6,})/,  // Common separators followed by password-like string
                        /\s+([A-Za-z0-9._!@#$%^&*]{8,30})/         // Spaces followed by complex string
                    ];
                    
                    let password = null;
                    
                    // Try each pattern
                    for (const pattern of passwordPatterns) {
                        const match = context.match(pattern);
                        if (match) {
                            password = match[1].trim();
                            
                            // Clean the password by removing TG IDs, etc.
                            password = this.cleanPassword(password);
                            break;
                        }
                    }
                    
                    // If no password found, generate a placeholder
                    if (!password) {
                        if (!this.options.aggressiveParsing) continue;
                        password = '[PASSWORD_NOT_FOUND]';
                    }
                    
                    // Create an account object with the email and password
                    const account = { email, password };
                    
                    // Extract other fields from the nearby context
                    // Look in a larger window for additional fields
                    const largerContext = input.substring(
                        Math.max(0, emailPos - 100),
                        Math.min(input.length, emailPos + 300)
                    );
                    
                    this.extractFields(account, largerContext);
                    
                    accounts.push(account);
                }
                
                return accounts;
            }
            
            // Extract fields from account data
            extractFields(account, data) {
                // Extract plan
                this.extractField(account, data, 'plan', this.fieldVariations.plan);
                
                // Extract expiration date
                this.extractField(account, data, 'expireDate', this.fieldVariations.expiredate);
                
                // Extract days left
                this.extractField(account, data, 'daysLeft', this.fieldVariations.daysleft);
                
                // Extract auto renew
                this.extractField(account, data, 'autoRenew', this.fieldVariations.autorenew, (value) => {
                    return value.toLowerCase() === 'true';
                });
                
                // Extract payment method
                this.extractField(account, data, 'paymentMethod', this.fieldVariations.paymentmethod);
                
                // Deep inspection for fields that might be in non-standard formats
                if (this.options.deepInspection) {
                    this.deepFieldInspection(account, data);
                }
                
                return account;
            }
            
            // Extract a specific field using multiple variations of the field name
            extractField(account, data, fieldName, variations, valueProcessor = null) {
                // Check if the field is already set
                if (account[fieldName] !== undefined) return;
                
                // Create a regex pattern for all variations of the field name
                const variationsPattern = variations.join('|');
                const regex = new RegExp(`(${variationsPattern})\\s*=\\s*([^|\\n]+)`, 'i');
                
                const match = data.match(regex);
                if (match) {
                    let value = match[2].trim();
                    
                    // Clean up the value (remove trailing junk)
                    value = value.replace(/}}"\s*$/, '').trim();
                    
                    // Apply custom processing if provided
                    if (valueProcessor && typeof valueProcessor === 'function') {
                        value = valueProcessor(value);
                    }
                    
                    account[fieldName] = value;
                    
                    // Track when autoRenew is explicitly provided in the input
                    if (fieldName === 'autoRenew') {
                        account.autoRenewExplicit = true;
                    }
                }
            }
            
            // Deep inspection for non-standard field formats
            deepFieldInspection(account, data) {
                // ... existing code ...
                
                // Look for auto renew in looser patterns
                if (account.autoRenew === undefined) {
                    if (data.match(/\b(?:auto\s*renewal|recurring)\s*[:=]?\s*true\b/i)) {
                        account.autoRenew = true;
                        account.autoRenewExplicit = true;  // Add this line
                    } else if (data.match(/\b(?:auto\s*renewal|recurring)\s*[:=]?\s*false\b/i)) {
                        account.autoRenew = false;
                        account.autoRenewExplicit = true;  // Add this line
                    }
                }
                
                // Look for plan duration pattern (X Month/Year)
                if (!account.plan) {
                    const planMatch = data.match(/\b(\d+\s*(?:Month|Year|Day|Week)s?)\b/i);
                    if (planMatch) {
                        account.plan = planMatch[1];
                    }
                }
                
                // Look for days left pattern (just a number near "day" word)
                if (!account.daysLeft) {
                    const daysMatch = data.match(/\b(\d+)\s*(?:day|days|d)\b/i);
                    if (daysMatch) {
                        account.daysLeft = daysMatch[1];
                    }
                }
                
                // Look for auto renew in looser patterns
                if (account.autoRenew === undefined) {
                    if (data.match(/\b(?:auto\s*renewal|recurring)\s*[:=]?\s*true\b/i)) {
                        account.autoRenew = true;
                    } else if (data.match(/\b(?:auto\s*renewal|recurring)\s*[:=]?\s*false\b/i)) {
                        account.autoRenew = false;
                    }
                }
                
                // Look for payment methods in a more flexible way
                if (!account.paymentMethod) {
                    // Check for known payment method names in the data
                    for (const method of Object.keys(this.paymentMethods)) {
                        if (data.includes(method)) {
                            account.paymentMethod = method;
                            break;
                        }
                    }
                }
            }
            
            // Emergency recovery when normal parsing fails
            emergencyRecovery(input) {
                const accounts = [];
                
                // Just look for email patterns at this point
                const emailPattern = /([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/g;
                const emails = [...input.matchAll(emailPattern)].map(m => m[1]);
                
                if (emails.length === 0) return accounts;
                
                // For each email, create a minimal account
                for (const email of emails) {
                    const account = {
                        email: email,
                        password: '[RECOVERY_MODE]'
                    };
                    
                    accounts.push(account);
                }
                
                return accounts;
            }
            
            // Post-process accounts to ensure consistency and fix issues
            postProcessAccounts(accounts) {
                const processed = [];
                
                // Remove duplicate accounts
                const uniqueEmails = new Set();
                
                for (const account of accounts) {
                    // Skip if we've already processed this email
                    const emailKey = account.email.toLowerCase();
                    if (uniqueEmails.has(emailKey)) continue;
                    
                    uniqueEmails.add(emailKey);
                    
                    // Ensure consistent field names and formats
                    this.normalizeAccount(account);
                    
                    processed.push(account);
                }
                
                return processed;
            }
            
            // Normalize account fields for consistency
            normalizeAccount(account) {
                // Ensure all accounts have the same set of fields
                const requiredFields = ['email', 'password', 'plan', 'expireDate', 'daysLeft', 'autoRenew', 'paymentMethod'];
                
                for (const field of requiredFields) {
                    if (account[field] === undefined) {
                        // Set default values for missing fields
                        if (field === 'autoRenew') {
                            account[field] = false;
                            // Initialize the explicit flag when normalizing
                            account.autoRenewExplicit = false;
                        } else if (field !== 'email' && field !== 'password') {
                            account[field] = null;
                        }
                    }
                }
                
                // Ensure autoRenewExplicit is set even if autoRenew is already defined
                if (account.autoRenewExplicit === undefined) {
                    account.autoRenewExplicit = false;
                }
                
                // Normalize autoRenew to be a boolean
                if (typeof account.autoRenew === 'string') {
                    account.autoRenew = account.autoRenew.toLowerCase() === 'true';
                }
                
                return account;
            }
            
            // Evaluate the quality of parsing results
            evaluateResultQuality(accounts, originalInput) {
                if (!accounts || accounts.length === 0) return 0;
                
                let quality = 0;
                
                // Count how many emails from the original input were found
                const emailPattern = /([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/g;
                const allEmails = [...originalInput.matchAll(emailPattern)].map(m => m[1].toLowerCase());
                const uniqueEmails = new Set(allEmails);
                
                // Count how many unique emails we found
                let foundEmails = 0;
                for (const account of accounts) {
                    if (uniqueEmails.has(account.email.toLowerCase())) {
                        foundEmails++;
                    }
                }
                
                // Base quality on percentage of emails found
                quality += (foundEmails / uniqueEmails.size) * 50;
                
                // Add points for completeness of fields
                let fieldCompleteness = 0;
                const importantFields = ['email', 'password', 'plan', 'expireDate', 'autoRenew'];
                
                for (const account of accounts) {
                    let accountCompleteness = 0;
                    for (const field of importantFields) {
                        if (account[field] !== undefined && account[field] !== null) {
                            accountCompleteness++;
                        }
                    }
                    fieldCompleteness += accountCompleteness / importantFields.length;
                }
                
                // Average field completeness across all accounts
                quality += (fieldCompleteness / accounts.length) * 50;
                
                return quality;
            }
            
            // Format the output for display
            formatOutput(accounts) {
                if (!accounts || accounts.length === 0) {
                    return 'No accounts found to format';
                }
                
                let output = '';
                
                accounts.forEach((account, index) => {
                    // Add separator between accounts
                    if (index > 0) {
                        output += '\n\n' + '‚Äî'.repeat(30) + '\n\n';
                    }
                    
                    // Format email
                    output += `üìß ${account.email}\n`;
                    
                    // Format password
                    output += `Password: \`${account.password}\`\n`;
                    
                    // Track if we've added any fields after password
                    let fieldsAdded = false;
                    
                    // Format plan
                    if (account.plan) {
                        output += `üóì Plan = ${account.plan}\n`;
                        fieldsAdded = true;
                    }
                    
                    // Format expiration date
                    if (account.expireDate) {
                        output += `‚è≥ ExpireDate = ${account.expireDate}\n`;
                        fieldsAdded = true;
                    }
                    
                    // Format days left
                    if (account.daysLeft) {
                        output += `‚è≥ DaysLeft = ${account.daysLeft}\n`;
                        fieldsAdded = true;
                    }
                    
                    // Format auto renew - ONLY if it was explicitly provided in the input
                    if (account.autoRenewExplicit === true) {
                        const autoRenewSymbol = account.autoRenew ? '‚úÖ' : '‚ùå';
                        output += `AutoRenew: ${autoRenewSymbol}\n`;
                        fieldsAdded = true;
                    }
                    
                    // Format payment method
                    if (account.paymentMethod) {
                        let paymentEmoji = 'üí≥'; // Default
                        
                        // Look up the emoji for this payment method
                        for (const [method, emoji] of Object.entries(this.paymentMethods)) {
                            if (account.paymentMethod.includes(method)) {
                                paymentEmoji = emoji;
                                break;
                            }
                        }
                        
                        output += `${paymentEmoji} PaymentMethod = ${account.paymentMethod}`;
                        // Add a newline if this is not the last field (though it typically would be)
                        if (!fieldsAdded) {
                            output += '\n';
                        }
                    }
                });
                
                return output;
            }
        }
        
        // Formatter logic
        document.getElementById('format-btn').addEventListener('click', async function() {
            const inputData = document.getElementById('input-data').value.trim();
            if (!inputData) {
                showNotification('Please enter some data to format', 'error');
                return;
            }
            
            // Show processing indicator
            const processingIndicator = document.getElementById('processing-indicator');
            processingIndicator.classList.add('active');
            
            // Update status badge
            const statusBadge = document.getElementById('status-badge');
            statusBadge.textContent = 'Processing...';
            
            // Get formatter options from settings
            const options = {
                aggressiveParsing: document.getElementById('aggressive-parsing').checked,
                multiStrategy: document.getElementById('multi-strategy').checked,
                deepInspection: document.getElementById('deep-inspection').checked,
                errorRecovery: document.getElementById('error-recovery').checked,
                removeTags: document.getElementById('remove-tags').checked
            };
            
            // Get custom removal patterns from the settings
            const patternInputs = document.querySelectorAll('.pattern-input');
            const customPatterns = Array.from(patternInputs)
                .map(input => input.value.trim())
                .filter(pattern => pattern.length > 0);
            
            // Create formatter instance
            const formatter = new UltraFormatter();
            formatter.setOptions(options);
            
            // Set custom patterns if provided
            if (customPatterns.length > 0) {
                formatter.setRemovalPatterns(customPatterns);
            }
            
            try {
                // Format the data
                const result = await formatter.format(inputData);
                
                // Update output
                if (result.success) {
                    document.getElementById('output-result').textContent = result.result;
                    showNotification(`${result.message}`, 'success');
                    statusBadge.textContent = `Success (${result.accounts.length} accounts)`;
                } else {
                    document.getElementById('output-result').textContent = 'Formatting failed: ' + result.message;
                    showNotification(result.message, 'error');
                    statusBadge.textContent = 'Failed';
                }
                
                // Scroll to output
                document.querySelector('.output-card').scrollIntoView({ behavior: 'smooth' });
            } catch (error) {
                console.error('Error formatting data:', error);
                document.getElementById('output-result').textContent = 'An error occurred: ' + error.message;
                showNotification('Error: ' + error.message, 'error');
                statusBadge.textContent = 'Error';
            } finally {
                // Hide processing indicator
                processingIndicator.classList.remove('active');
            }
        });
        
        document.getElementById('clear-btn').addEventListener('click', function() {
            document.getElementById('input-data').value = '';
            document.getElementById('output-result').textContent = 'Your magical formatted output will appear here...';
            showNotification('Input cleared!', 'success');
            
            // Reset status badge
            document.getElementById('status-badge').textContent = 'Ready';
        });
        
        document.getElementById('copy-btn').addEventListener('click', function() {
            const outputText = document.getElementById('output-result').textContent;
            if (outputText === 'Your magical formatted output will appear here...') {
                showNotification('Nothing to copy yet!', 'error');
                return;
            }
            
            navigator.clipboard.writeText(outputText)
                .then(() => showNotification('Copied to clipboard!', 'success'))
                .catch(err => showNotification('Failed to copy: ' + err, 'error'));
        });
        
        // Portal activation
        document.getElementById('portal-button').addEventListener('click', function(e) {
            // Prevent instant navigation
            e.preventDefault();
            
            // Create URL to navigate to
            const portalUrl = 'https://github.com/Darkphoenixir';
            
            // Activate portal effects
            document.body.classList.add('portal-active');
            
            // Create additional magical particles
            for (let i = 0; i < 20; i++) {
                createMagicalParticle();
            }
            
            // Navigate after animation completes
            setTimeout(function() {
                window.open(portalUrl, '_blank');
                // Reset effects after a moment
                setTimeout(function() {
                    document.body.classList.remove('portal-active');
                }, 500);
            }, 2000);
        });
        
        // Create magical particles for portal effect
        function createMagicalParticle() {
            const particle = document.createElement('div');
            particle.className = 'particle portal-particle';
            particle.style.left = `${Math.random() * 100}%`;
            particle.style.top = `${Math.random() * 100}%`;
            particle.style.opacity = `${Math.random() * 0.7 + 0.3}`;
            particle.style.width = `${Math.random() * 10 + 5}px`;
            particle.style.height = particle.style.width;
            particle.style.background = `hsl(${260 + Math.random() * 60}, 100%, 70%)`;
            particle.style.boxShadow = `0 0 ${Math.random() * 10 + 5}px ${particle.style.background}`;
            particle.style.zIndex = '15';
            
            document.getElementById('particles').appendChild(particle);
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 2500);
        }
        
        function showNotification(message, type) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Properly handle remove pattern button
        document.body.addEventListener('click', function(e) {
            // Check if the clicked element is a remove-pattern button
            if (e.target.classList.contains('remove-pattern') || 
                (e.target.parentElement && e.target.parentElement.classList.contains('remove-pattern'))) {
                
                // Get the pattern field to remove
                const patternField = e.target.closest('.pattern-field');
                if (patternField) {
                    patternField.remove();
                }
            }
        });

        // Music Player Setup
        const backgroundMusic = document.getElementById('background-music');
        const audioSource = document.getElementById('audio-source');
        const musicPlayer = document.getElementById('music-player');
        const musicToggle = document.getElementById('music-toggle');
        const playIcon = document.getElementById('play-icon');
        const prevTrack = document.getElementById('prev-track');
        const nextTrack = document.getElementById('next-track');
        const musicTitle = document.getElementById('music-title');
        const musicArtist = document.getElementById('music-artist');
        const volumeSlider = document.getElementById('volume-slider');
        const visualizerToggle = document.getElementById('visualizer-toggle');
        const shuffleToggle = document.getElementById('shuffle-toggle');
        const visualizerContainer = document.getElementById('visualizer-container');
        const musicProgressBar = document.getElementById('music-progress-bar');
        const musicNotification = document.getElementById('music-notification');
        const musicStartOverlay = document.getElementById('music-start-overlay');
        const immersiveVisualizer = document.getElementById('immersive-visualizer');
        const magicPath = document.getElementById('magic-path');
        
        // Player state
        let currentTrackIndex = 0;
        let isPlaying = false;
        let visualizerActive = false;
        let immersiveMode = false;
        let shuffleActive = false;
        let animationFrame;
        let beatDetected = false;
        let lastBeatTime = 0;
        let sensitivityThreshold = 130; // Beat detection threshold
        let reactiveElements = [];
        
        // Audio Context for Visualization
        let audioContext;
        let analyser;
        let source;
        let dataArray;
        let visualizerCanvas;
        let visualizerCtx;
        
        // Show music start overlay
        setTimeout(() => {
            musicStartOverlay.classList.add('show');
        }, 1000);
        
        // Start music on overlay click (required for audio to work in most browsers)
        musicStartOverlay.addEventListener('click', () => {
            musicStartOverlay.classList.remove('show');
            
            // Initialize audio context and start playing music
            initAudioContext();
            
            // Show music player
            setTimeout(() => {
                musicPlayer.classList.add('show');
            }, 500);
            
            // Enable immersive visualizer
            immersiveMode = true;
            immersiveVisualizer.classList.add('active');
            startImmersiveVisualizer();
            
            // Start playing music
            togglePlayback(true);
        });
        
        // Initialize Audio Context
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    source = audioContext.createMediaElementSource(backgroundMusic);
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                    
                    // Set up analyzer
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    
                    // Set up visualizer canvas
                    visualizerCanvas = document.getElementById('visualizer');
                    visualizerCtx = visualizerCanvas.getContext('2d');
                    
                    // Set canvas size
                    resizeCanvas();
                    window.addEventListener('resize', resizeCanvas);
                    
                    console.log("Audio context initialized successfully");
                } catch (e) {
                    console.error("Web Audio API error:", e);
                    showMusicNotification('Audio initialization error. Please try reloading the page.');
                }
            }
        }
        
        // Toggle playback with optional force state
        function togglePlayback(forceState = null) {
            const newState = forceState !== null ? forceState : !isPlaying;
            
            if (newState && !isPlaying) {
                // Initialize context if needed
                if (!audioContext) {
                    initAudioContext();
                }
                
                backgroundMusic.play().then(() => {
                    isPlaying = true;
                    playIcon.className = 'fas fa-pause';
                    showMusicNotification(`Now playing: ${playlist[currentTrackIndex].title}`);
                    startOrbCreation();
                    startImmersiveVisualizer();
                    
                    // Add reactive classes to elements
                    addReactiveClasses();
                }).catch(e => {
                    console.error("Error playing audio:", e);
                    showMusicNotification('Error playing music. Try clicking anywhere on the page first.');
                });
            } else if (!newState && isPlaying) {
                backgroundMusic.pause();
                isPlaying = false;
                playIcon.className = 'fas fa-play';
                showMusicNotification('Music paused');
                stopOrbCreation();
                
                // Remove reactive animation
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }
            }
        }
        
        // Initialize the music player
        function initMusicPlayer() {
            // Select a random track initially
            currentTrackIndex = Math.floor(Math.random() * playlist.length);
            
            // Shuffle the playlist if enabled
            if (shuffleActive) {
                shufflePlaylist();
            }
            
            // Load the first track
            loadTrack(currentTrackIndex);
            
            // Set initial volume
            backgroundMusic.volume = volumeSlider.value / 100;
            
            // Find elements to add reactive effects to
            findReactiveElements();
        }
        
        // Add reactive classes to elements for music visualization
        function addReactiveClasses() {
            // Add reactive classes to certain elements
            document.querySelectorAll('.header, .section-title, .feature-tag, .settings-toggle, h3, .button')
                .forEach(el => {
                    el.classList.add('music-reactive');
                    reactiveElements.push(el);
                });
            
            // Add glow effects to buttons and input areas
            document.querySelectorAll('.button, .input-area, .output-area')
                .forEach(el => {
                    el.classList.add('glow-effect');
                });
            
            // Add text glow effects
            document.querySelectorAll('.section-title, h3, .header')
                .forEach(el => {
                    el.classList.add('glow-text');
                });
        }
        
        // Find all elements that can be reactive to music
        function findReactiveElements() {
            reactiveElements = Array.from(document.querySelectorAll('.music-reactive, .floating-icon, .particle'));
        }
        
        // Load a specific track
        function loadTrack(trackIndex) {
            if (trackIndex < 0) trackIndex = playlist.length - 1;
            if (trackIndex >= playlist.length) trackIndex = 0;
            
            currentTrackIndex = trackIndex;
            const currentTrack = playlist[currentTrackIndex];
            
            // Update audio source
            audioSource.src = currentTrack.src;
            backgroundMusic.load();
            
            // Update track info
            musicTitle.textContent = currentTrack.title;
            musicArtist.textContent = currentTrack.artist;
            
            // If was playing before, start playing the new track
            if (isPlaying) {
                backgroundMusic.play()
                    .then(() => {
                        showMusicNotification(`Now playing: ${currentTrack.title}`);
                    })
                    .catch(e => {
                        console.error("Error playing audio", e);
                        showMusicNotification('Error playing music');
                    });
            }
            
            // Reset progress bar
            musicProgressBar.style.width = '0%';
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Create floating icons and particles
            // ... existing code ...
            
            // Initialize the music player
            initMusicPlayer();
            
            // Music Toggle
            musicToggle.addEventListener('click', () => {
                togglePlayback();
            });
            
            // Previous Track button
            prevTrack.addEventListener('click', () => {
                playPreviousTrack();
            });
            
            // Next Track button
            nextTrack.addEventListener('click', () => {
                playNextTrack();
            });
            
            // Shuffle Toggle
            shuffleToggle.addEventListener('click', () => {
                shuffleActive = !shuffleActive;
                
                if (shuffleActive) {
                    shuffleToggle.classList.add('active');
                    shufflePlaylist();
                } else {
                    shuffleToggle.classList.remove('active');
                    showMusicNotification('Shuffle disabled');
                }
            });
            
            // Auto play next track when current one ends
            backgroundMusic.addEventListener('ended', () => {
                playNextTrack();
            });
            
            // Volume Control
            volumeSlider.addEventListener('input', () => {
                const volume = volumeSlider.value / 100;
                backgroundMusic.volume = volume;
            });
            
            // Visualizer Toggle
            visualizerToggle.addEventListener('click', () => {
                visualizerActive = !visualizerActive;
                
                if (visualizerActive) {
                    visualizerContainer.classList.add('active');
                    visualizerToggle.style.color = 'var(--secondary)';
                    if (isPlaying && !animationFrame) {
                        drawVisualizer();
                    }
                } else {
                    visualizerContainer.classList.remove('active');
                    visualizerToggle.style.color = 'var(--light)';
                    if (animationFrame) {
                        cancelAnimationFrame(animationFrame);
                        animationFrame = null;
                    }
                }
            });
            
            // Update progress bar
            backgroundMusic.addEventListener('timeupdate', () => {
                const percent = (backgroundMusic.currentTime / backgroundMusic.duration) * 100;
                musicProgressBar.style.width = `${percent}%`;
            });
        });
        
        // Start immersive visualizer effects
        function startImmersiveVisualizer() {
            if (!isPlaying || !analyser || !dataArray) return;
            
            // Clear any existing animation frame
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            animationFrame = requestAnimationFrame(updateImmersiveVisualizer);
        }
        
        // Update the immersive visualizer
        function updateImmersiveVisualizer() {
            if (!isPlaying) {
                animationFrame = null;
                return;
            }
            
            animationFrame = requestAnimationFrame(updateImmersiveVisualizer);
            
            // Get frequency data
            analyser.getByteFrequencyData(dataArray);
            
            // Calculate average frequency and beat detection
            const average = calculateAverageFrequency(dataArray);
            const isBeat = detectBeat(dataArray, average);
            
            // Update standard visualizer if active
            if (visualizerActive) {
                drawVisualizer();
            }
            
            // Create frequency circles based on audio data
            if (Math.random() < 0.1) {
                createFrequencyCircle(average);
            }
            
            // Create beat ripple when beat is detected
            if (isBeat) {
                createBeatRipple();
                
                // Make particles react to beat
                document.querySelectorAll('.floating-icon').forEach(icon => {
                    icon.style.transform = `scale(${1 + average/600})`;
                    setTimeout(() => {
                        icon.style.transform = 'scale(1)';
                    }, 200);
                });
            }
            
            // Update reactive elements
            updateReactiveElements(dataArray, average);
            
            // Create frequency particles that follow a path
            if (Math.random() < 0.05) {
                createFrequencyParticle(average);
            }
        }
        
        // Calculate the average frequency from the data array
        function calculateAverageFrequency(dataArray) {
            return dataArray.reduce((acc, val) => acc + val, 0) / dataArray.length;
        }
        
        // Detect a beat in the music
        function detectBeat(dataArray, average) {
            // Focus on bass frequencies (lower indices in the array)
            const bassAvg = dataArray.slice(0, 10).reduce((acc, val) => acc + val, 0) / 10;
            
            // Check if we have a beat and it's been at least 300ms since the last one
            const now = Date.now();
            if (bassAvg > sensitivityThreshold && now - lastBeatTime > 300) {
                lastBeatTime = now;
                return true;
            }
            return false;
        }
        
        // Create a frequency circle based on audio data
        function createFrequencyCircle(intensity) {
            if (!immersiveVisualizer) return;
            
            const circle = document.createElement('div');
            circle.className = 'frequency-circle';
            
            // Random position
            const xPos = Math.random() * window.innerWidth;
            const yPos = Math.random() * window.innerHeight;
            circle.style.left = `${xPos}px`;
            circle.style.top = `${yPos}px`;
            
            // Size based on frequency intensity
            const size = 20 + (intensity * 1.2);
            circle.style.width = `${size}px`;
            circle.style.height = `${size}px`;
            
            // Opacity based on intensity
            const opacity = Math.min(0.7, intensity / 255);
            circle.style.opacity = opacity;
            
            // Color based on frequency (more vibrant for higher frequencies)
            const hue = 270 + (intensity / 255) * 40;
            circle.style.background = `radial-gradient(circle at center, hsla(${hue}, 80%, 60%, ${opacity}) 0%, transparent 70%)`;
            
            immersiveVisualizer.appendChild(circle);
            
            // Animate and remove
            gsap.to(circle, {
                duration: 3 + Math.random() * 2,
                scale: 3 + Math.random() * 2,
                opacity: 0,
                ease: "power2.out",
                onComplete: () => {
                    if (circle.parentNode) {
                        circle.parentNode.removeChild(circle);
                    }
                }
            });
        }
        
        // Create a beat ripple effect
        function createBeatRipple() {
            const ripple = document.createElement('div');
            ripple.className = 'beat-ripple';
            document.body.appendChild(ripple);
            
            // Add animation class
            ripple.classList.add('animate');
            
            // Remove after animation completes
            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, 2000);
        }
        
        // Create a particle that follows a path based on audio frequencies
        function createFrequencyParticle(intensity) {
            if (!magicPath) return;
            
            const particle = document.createElement('div');
            particle.className = 'frequency-particle';
            
            // Size based on frequency
            const size = 5 + (intensity / 20);
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            
            // Random starting position along the edges
            let startX, startY;
            const edge = Math.floor(Math.random() * 4);
            
            switch(edge) {
                case 0: // Top
                    startX = Math.random() * window.innerWidth;
                    startY = 0;
                    break;
                case 1: // Right
                    startX = window.innerWidth;
                    startY = Math.random() * window.innerHeight;
                    break;
                case 2: // Bottom
                    startX = Math.random() * window.innerWidth;
                    startY = window.innerHeight;
                    break;
                case 3: // Left
                    startX = 0;
                    startY = Math.random() * window.innerHeight;
                    break;
            }
            
            particle.style.left = `${startX}px`;
            particle.style.top = `${startY}px`;
            
            // Color based on frequency
            const hue = 260 + (intensity / 255) * 60;
            const brightness = 50 + (intensity / 255) * 30;
            particle.style.background = `radial-gradient(circle at center, hsl(${hue}, 70%, ${brightness}%) 0%, transparent 70%)`;
            
            magicPath.appendChild(particle);
            
            // Create a random path for the particle to follow
            const controlPoints = [];
            const numPoints = 3 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < numPoints; i++) {
                controlPoints.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight
                });
            }
            
            // Final destination
            const endX = Math.random() * window.innerWidth;
            const endY = Math.random() * window.innerHeight;
            
            // Animate along the path
            gsap.to(particle, {
                duration: 5 + Math.random() * 3,
                motionPath: {
                    path: controlPoints,
                    curviness: 1.5
                },
                left: endX,
                top: endY,
                scale: 0.2,
                opacity: 0,
                ease: "power1.inOut",
                onComplete: () => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }
            });
        }
        
        // Update elements to react to music
        function updateReactiveElements(dataArray, average) {
            if (!reactiveElements.length) return;
            
            // Different frequency bands for different effects
            const bassAvg = dataArray.slice(0, 10).reduce((acc, val) => acc + val, 0) / 10;
            const midAvg = dataArray.slice(10, 20).reduce((acc, val) => acc + val, 0) / 10;
            const highAvg = dataArray.slice(20, 30).reduce((acc, val) => acc + val, 0) / 10;
            
            // Scale the container slightly with bass
            const container = document.querySelector('.container');
            if (container) {
                const scaleAmount = 1 + (bassAvg / 2000);
                container.style.transform = `scale(${scaleAmount})`;
            }
            
            // Make reactive elements pulse with the mid-frequencies
            reactiveElements.forEach((el, i) => {
                // Apply different effects based on element type
                if (el.classList.contains('floating-icon')) {
                    const moveAmount = (midAvg / 255) * 10;
                    el.style.transform = `translateY(${-moveAmount}px)`;
                } else if (el.classList.contains('section-title') || el.classList.contains('header')) {
                    const glowAmount = (highAvg / 255) * 15;
                    el.style.textShadow = `0 0 ${glowAmount}px rgba(155, 109, 255, 0.8)`;
                } else if (el.classList.contains('glow-effect')) {
                    const glowAmount = (midAvg / 255) * 15;
                    el.style.boxShadow = `0 0 ${glowAmount}px rgba(155, 109, 255, 0.5)`;
                } else {
                    // For other elements, just pulse slightly
                    const pulseAmount = 1 + ((midAvg / 255) * 0.05);
                    el.style.transform = `scale(${pulseAmount})`;
                }
            });
        }
        
        // ... existing functions ...

        // ... existing code ...

        // Function to resize canvas
        function resizeCanvas() {
            if (visualizerCanvas) {
                visualizerCanvas.width = visualizerContainer.clientWidth;
                visualizerCanvas.height = visualizerContainer.clientHeight;
            }
        }
        
        // Draw visualizer function
        function drawVisualizer() {
            if (!visualizerActive || !isPlaying) {
                animationFrame = null;
                return;
            }
            
            animationFrame = requestAnimationFrame(drawVisualizer);
            
            analyser.getByteFrequencyData(dataArray);
            
            visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            
            const barWidth = (visualizerCanvas.width / dataArray.length) * 2.5;
            let barHeight;
            let x = 0;
            
            for (let i = 0; i < dataArray.length; i++) {
                barHeight = dataArray[i] / 2;
                
                // Create gradient color based on frequency
                const gradient = visualizerCtx.createLinearGradient(0, 0, 0, visualizerCanvas.height);
                gradient.addColorStop(0, `rgba(155, 109, 255, ${dataArray[i] / 255})`);
                gradient.addColorStop(1, `rgba(255, 107, 151, ${dataArray[i] / 255 * 0.5})`);
                
                visualizerCtx.fillStyle = gradient;
                
                // Draw rounded bars
                visualizerCtx.beginPath();
                visualizerCtx.moveTo(x, visualizerCanvas.height - barHeight);
                visualizerCtx.lineTo(x + barWidth, visualizerCanvas.height - barHeight);
                visualizerCtx.lineTo(x + barWidth, visualizerCanvas.height);
                visualizerCtx.lineTo(x, visualizerCanvas.height);
                visualizerCtx.closePath();
                visualizerCtx.fill();
                
                // Add glow effect
                visualizerCtx.shadowColor = 'rgba(155, 109, 255, 0.8)';
                visualizerCtx.shadowBlur = 15;
                
                x += barWidth + 1;
            }
        }
        
        // Show music notification
        function showMusicNotification(message) {
            musicNotification.textContent = message;
            musicNotification.classList.add('show');
            
            setTimeout(() => {
                musicNotification.classList.remove('show');
            }, 2000);
        }
        
        // Sound visualization orbs
        function createSoundOrb() {
            if (!isPlaying) return;
            
            // Get current audio frequency data if available
            let intensity = 50;
            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray);
                // Use average of frequency values for intensity
                intensity = dataArray.reduce((acc, val) => acc + val, 0) / dataArray.length;
            }
            
            const size = Math.max(20, Math.min(100, intensity * 1.5));
            const orb = document.createElement('div');
            orb.className = 'sound-orb';
            
            // Position randomly at bottom of screen
            const xPos = Math.random() * window.innerWidth;
            orb.style.left = `${xPos}px`;
            orb.style.bottom = '0';
            orb.style.width = `${size}px`;
            orb.style.height = `${size}px`;
            
            // Set opacity based on intensity
            const opacity = Math.min(0.8, intensity / 255);
            orb.style.opacity = opacity;
            
            // Set animation duration based on intensity
            const animDuration = Math.max(3, 10 - (intensity / 255) * 5);
            orb.style.animationDuration = `${animDuration}s`;
            
            document.body.appendChild(orb);
            
            // Remove after animation completes
            setTimeout(() => {
                if (orb.parentNode) {
                    orb.parentNode.removeChild(orb);
                }
            }, animDuration * 1000);
        }
        
        // Create floating music notes
        function createMusicFloater() {
            if (!isPlaying) return;
            
            const floater = document.createElement('div');
            floater.className = 'music-floater';
            
            // Random position on screen
            const xPos = Math.random() * window.innerWidth;
            const yPos = Math.random() * window.innerHeight;
            floater.style.left = `${xPos}px`;
            floater.style.top = `${yPos}px`;
            
            // Random size
            const size = 20 + Math.random() * 30;
            floater.style.width = `${size}px`;
            floater.style.height = `${size}px`;
            
            document.body.appendChild(floater);
            
            // Remove after animation completes
            setTimeout(() => {
                if (floater.parentNode) {
                    floater.parentNode.removeChild(floater);
                }
            }, 3000);
        }
        
        let orbInterval;
        let floaterInterval;
        
        function startOrbCreation() {
            if (orbInterval) clearInterval(orbInterval);
            if (floaterInterval) clearInterval(floaterInterval);
            
            // Create orbs regularly
            orbInterval = setInterval(createSoundOrb, 1000);
            
            // Create music floaters periodically
            floaterInterval = setInterval(createMusicFloater, 2000);
            
            // Start visualization if active
            if (visualizerActive && !animationFrame) {
                drawVisualizer();
            }
        }
        
        function stopOrbCreation() {
            if (orbInterval) {
                clearInterval(orbInterval);
                orbInterval = null;
            }
            
            if (floaterInterval) {
                clearInterval(floaterInterval);
                floaterInterval = null;
            }
            
            // Stop visualization animation
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
        }

        // ... existing code ...

        // ... existing code ...

        // Play the previous track
        function playPreviousTrack() {
            loadTrack(currentTrackIndex - 1);
        }
        
        // Play the next track
        function playNextTrack() {
            loadTrack(currentTrackIndex + 1);
        }
        
        // Shuffle the playlist
        function shufflePlaylist() {
            for (let i = playlist.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [playlist[i], playlist[j]] = [playlist[j], playlist[i]];
            }
            
            // If we're shuffling while playing, reload the current track
            if (isPlaying) {
                currentTrackIndex = 0;
                loadTrack(currentTrackIndex);
            }
            
            showMusicNotification('Playlist shuffled');
        }
    </script>
</body>
</html>
